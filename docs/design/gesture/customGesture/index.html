<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">自定义触摸反馈 | 你好 Compose</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://milklab.dev/docs/design/gesture/customGesture"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="自定义触摸反馈 | 你好 Compose"><meta data-react-helmet="true" name="description" content="通过前面 Draggable 修饰符、Swipeable 修饰符、Transformable 修饰符以及 NestedScroll 修饰符使用方法的学习，想必大家已经可以处理一些常见手势需求了。然而针对复杂手势需求，我们就需要对 Compose 中的手势处理有更深入的理解。实际上前面所提到的手势处理修饰符都是基于低级别的 PointerInput 修饰符进行封装实现的，所以弄清楚 PointerInput 修饰符的使用方法，有助于我们对高级别手势处理修饰符的理解，并且能够帮助我们更好的完成上层开发实现各种复杂的手势需求。"><meta data-react-helmet="true" property="og:description" content="通过前面 Draggable 修饰符、Swipeable 修饰符、Transformable 修饰符以及 NestedScroll 修饰符使用方法的学习，想必大家已经可以处理一些常见手势需求了。然而针对复杂手势需求，我们就需要对 Compose 中的手势处理有更深入的理解。实际上前面所提到的手势处理修饰符都是基于低级别的 PointerInput 修饰符进行封装实现的，所以弄清楚 PointerInput 修饰符的使用方法，有助于我们对高级别手势处理修饰符的理解，并且能够帮助我们更好的完成上层开发实现各种复杂的手势需求。"><link data-react-helmet="true" rel="icon" href="/img/logo.svg"><link data-react-helmet="true" rel="canonical" href="https://milklab.dev/docs/design/gesture/customGesture"><link data-react-helmet="true" rel="alternate" href="https://milklab.dev/docs/design/gesture/customGesture" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://milklab.dev/docs/design/gesture/customGesture" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.cba56bc1.css">
<link rel="preload" href="/assets/js/runtime~main.be34a282.js" as="script">
<link rel="preload" href="/assets/js/main.01e4ab04.js" as="script">
</head>
<body data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Jetpack Compose 博物馆</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/">文档</a><a class="navbar__item navbar__link" href="/docs/open-source-project/compose-douban">开源项目</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/milklabdev/jetpack-compose-book" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">写在开头</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/入门">入门</a><button aria-label="Toggle the collapsible sidebar category &#x27;入门&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/installation">安装或更新 Android Studio</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorial">初识 Jetpack Compose</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/elements/alertdialog">基础组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/layout/box">布局组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" href="/docs/category/设计">设计</a><button aria-label="Toggle the collapsible sidebar category &#x27;设计&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/动画animation">动画（Animation）</a><button aria-label="Toggle the collapsible sidebar category &#x27;动画（Animation）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/主题theming">主题（Theming）</a><button aria-label="Toggle the collapsible sidebar category &#x27;主题（Theming）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" tabindex="0" href="/docs/category/手势gesture">手势（Gesture）</a><button aria-label="Toggle the collapsible sidebar category &#x27;手势（Gesture）&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/gesture/overview">概述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/gesture/draggable">拖动（Draggable）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/gesture/swipeable">滑动（Swipeable）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/gesture/transformer">双指拖动、缩放与旋转（Transformer）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/gesture/nestedScroll">嵌套滑动（nestedScroll）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/design/gesture/customGesture">自定义触摸反馈</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/列表lists">列表（Lists）</a><button aria-label="Toggle the collapsible sidebar category &#x27;列表（Lists）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/图形graphics">图形（Graphics）</a><button aria-label="Toggle the collapsible sidebar category &#x27;图形（Graphics）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/resources">资源</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/技术原理">技术原理</a><button aria-label="Toggle the collapsible sidebar category &#x27;技术原理&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>自定义触摸反馈</h1></header><p>通过前面 <code>Draggable</code> 修饰符、<code>Swipeable</code> 修饰符、<code>Transformable</code> 修饰符以及 <code>NestedScroll</code> 修饰符使用方法的学习，想必大家已经可以处理一些常见手势需求了。然而针对复杂手势需求，我们就需要对 Compose 中的手势处理有更深入的理解。实际上前面所提到的手势处理修饰符都是基于低级别的 <code>PointerInput</code> 修饰符进行封装实现的，所以弄清楚 <code>PointerInput</code> 修饰符的使用方法，有助于我们对高级别手势处理修饰符的理解，并且能够帮助我们更好的完成上层开发实现各种复杂的手势需求。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="使用-pointerinput-modifier">使用 PointerInput Modifier<a class="hash-link" href="#使用-pointerinput-modifier" title="Direct link to heading">​</a></h2><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Modifier.pointerInput(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vararg keys: Any?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block: suspend PointerInputScope.() -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): Modifier = composed(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    remember(density) { SuspendingPointerInputFilter(viewConfiguration, density) }.apply {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LaunchedEffect(this, *keys) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            block()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>使用 <code>PointerInput</code> 修饰符时我们需要传入两个参数，<code>keys</code> 与 <code>block</code>。</p><ul><li><strong>keys：</strong>当 Composable 组件发生重组时，如果传入的 keys 发生了变化，则手势事件处理过程会被中断。</li><li><strong>block：</strong>在这个 <code>PointerInputScope</code> 类型作用域代码块中我们便可以声明手势事件处理逻辑了。通过 suspend 关键字可知这是个协程体，这意味着在 Compose 中手势处理最终都发生在协程中。如果你对协程还不了解的话，可能需要额外的拓展学习一下了，伴随着越来越多的主流开发框架拥抱协程，协程将会成为Android 开发者未来必须掌握的技能。</li></ul><p>我们在 <code>PointerInputScope</code> 接口声明中能够找到所有可用的手势处理方法，我们可以通过这些方法获取到更加详细的手势信息以及更加细粒度的手势事件处理，接下来我们先来介绍 <code>PointerInputScope</code> 中的 <code>GestureDetector</code> 系列 API 方法。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="拖动类型基础-api">拖动类型基础 API<a class="hash-link" href="#拖动类型基础-api" title="Direct link to heading">​</a></h3><p>谈到拖动监听，许多人第一个反应就是前面所提到的 <code>Draggable</code> 修饰符。<code>Draggable</code> 修饰符作为手势处理的高层次封装，在监听 UI 组件拖动手势的基础能力上也附加了许多特性与限制，同时也隐藏了一些细粒度的手势事件回调设置。例如在 <code>Draggable</code> 修饰符中我们只能监听水平或垂直两个方向的拖动手势，所以为了能够更完整的监听拖动手势，Compose 为我们提供了低级别的 <code>detectDragGestures</code> 系列 API。</p><table><thead><tr><th>API名称</th><th>作用</th></tr></thead><tbody><tr><td>detectDragGestures</td><td>监听拖动手势</td></tr><tr><td>detectDragGesturesAfterLongPress</td><td>监听长按后的拖动手势</td></tr><tr><td>detectHorizontalDragGestures</td><td>监听水平拖动手势</td></tr><tr><td>detectVerticalDragGestures</td><td>监听垂直拖动手势</td></tr></tbody></table><p>这类拖动监听 API 功能上相类似，使用时需要传入参数也比较相近。我们可以根据实际情况来选用不同 API。在使用这些 API 时，我们可以定制在不同时机的处理回调，以 <code>detectDragGestures</code> 为例。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun PointerInputScope.detectDragGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragStart: (Offset) -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragEnd: () -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragCancel: () -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDrag: (change: PointerInputChange, dragAmount: Offset) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这里提供了四个回调时机，<code>onDragStart</code> 会在拖动开始时回调，<code>onDragEnd</code> 会在拖动结束时回调，<code>onDragCancel</code> 会在拖动取消时回调，而 <code>onDrag</code> 则会在拖动真正发生时回调。</p><blockquote><p>注意：onDragCancel 触发时机多发生于滑动冲突的场景，子组件可能最开始是可以获取到拖动事件的，当拖动手势事件达到莫个指定条件时可能会被父组件劫持消费，这种场景下便会执行 onDragCancel 回调。所以 onDragCancel 回调主要依赖于实际业务逻辑。</p></blockquote><p>我们可以利用 <code>detectDragGestures</code> 轻松的实现拖动手势监听。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun DragGestureDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var boxSize = 100.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var offset by remember { mutableStateOf(Offset.Zero) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Box(contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier = Modifier.fillMaxSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .size(boxSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .offset {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IntOffset(offset.x.roundToInt(), offset.y.roundToInt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        detectDragGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          onDragStart = { offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Log.d(TAG, &quot;拖动开始了～&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          onDragEnd = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Log.d(TAG, &quot;拖动结束了～&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          onDragCancel = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Log.d(TAG, &quot;拖动取消了～&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          onDrag = { change: PointerInputChange, dragAmount: Offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Log.d(TAG, &quot;拖动中～&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            offset += dragAmount</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div align="center"><img src="/assets/images/drag-80a95888973e3f8aff22b90304b4086d.gif" width="50%" height="50%"></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="点击类型基础-api">点击类型基础 API<a class="hash-link" href="#点击类型基础-api" title="Direct link to heading">​</a></h3><p>在 <code>PointerInputScope</code> 中，我们可以使用 <code>detectTapGestures</code> 设置更细粒度的点击监听回调。作为低级别点击监听 API，在发生点击时不会带有像 <code>Clickable</code> 修饰符与 <code>CombinedClickable</code> 修饰符那样会为所修饰的组件施加一个涟漪波纹效果动画的蒙层，我们能够根据需要进行更灵活的上层定制。</p><table><thead><tr><th>API名称</th><th>作用</th></tr></thead><tbody><tr><td>detectTapGestures</td><td>监听点击手势</td></tr></tbody></table><p><code>detectTapGestures</code> 提供了四个可选事件回调，可以根据需求来设置不同点击事件回调。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun PointerInputScope.detectTapGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  onDoubleTap: ((Offset) -&gt; Unit)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  onLongPress: ((Offset) -&gt; Unit)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  onPress: suspend PressGestureScope.(Offset) -&gt; Unit = NoPressGesture,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  onTap: ((Offset) -&gt; Unit)? = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ul><li>onDoubleTap (可选)：双击时回调</li><li>onLongPress (可选)：长按时回调</li><li>onPress (可选)：按下时回调</li><li>onTap (可选)：轻触时回调</li></ul><p>这几种点击事件回调存在着先后次序的，并不是每次只会执行其中一个。<code>onPress</code> 是最普通的 <code>ACTION_DOWN</code> 事件，你的手指一旦按下便会回调。如果你连着按了两下，则会在执行两次 <code>onPress</code> 后执行 <code>onDoubleTap</code>。如果你的手指按下后不抬起，当达到长按的判定阈值 (400ms) 会执行 <code>onLongPress</code>。如果你的手指按下后快速抬起，在轻触的判定阈值内(100ms)会执行 <code>onTap</code> 回调。</p><p>总的来说， <code>onDoubleTap</code> 回调前必定会先回调 2 次 Press，而 onLongPress 与 onTap 回调前必定会回调 1 次 Press。</p><p> <code>detectTapGestures</code> 使用起来非常简单，我们根据需求来设置不同点击事件回调即可。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun TapGestureDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var boxSize = 100.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(boxSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                detectTapGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onDoubleTap = { offset: Offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Log.d(TAG, &quot;发生双击操作了～&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onLongPress = { offset: Offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Log.d(TAG, &quot;发生长按操作了～&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onPress = {  offset: Offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Log.d(TAG, &quot;发生按下操作了～&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onTap = {  offset: Offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Log.d(TAG, &quot;发生轻触操作了～&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="变换类型基础-api">变换类型基础 API<a class="hash-link" href="#变换类型基础-api" title="Direct link to heading">​</a></h3><p>使用 <code>detectTransformGestures</code> 可以获取到双指拖动、缩放与旋转手势操作中更具体的手势信息，例如重心。</p><table><thead><tr><th>API名称</th><th>作用</th></tr></thead><tbody><tr><td>detectTransformGestures</td><td>监听拖动、缩放与旋转手势</td></tr></tbody></table><p>与 <code>Transfomer</code> 修饰符不同的是，通过这个 API 可以监听单指的拖动手势，和拖动类型基础 API所提供的功能一样，除此之外还支持监听双指缩放与旋转手势。反观 <code>Transfomer</code> 修饰符 只能监听到双指拖动手势，不知设计成这样的行为不一致是否是官方有意为之。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun PointerInputScope.detectTransformGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    panZoomLock: Boolean = false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onGesture: (centroid: Offset, pan: Offset, zoom: Float, rotation: Float) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>与 <code>Tranformable</code> 修饰符一样，<code>detectTransformGestures</code> 方法提供了两个参数。</p><ul><li><strong>panZoomLock</strong>(可选)： 当拖动或缩放手势发生时是否支持旋转</li><li><strong>onGesture</strong>(必须)：当拖动、缩放或旋转手势发生时回调</li></ul><p>使用起来十分简单，我们仅需根据手势信息来更新状态就可以了。当我们处理旋转、缩放与拖动这类手势时，需要格外的注意 <code>Modifier</code> 调用次序，因为这会影响最终呈现效果。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Preview</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun TransformGestureDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var boxSize = 100.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var offset by remember { mutableStateOf(Offset.Zero) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var ratationAngle by remember { mutableStateOf(0f) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var scale by remember { mutableStateOf(1f) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(boxSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .rotate(ratationAngle) // 需要注意offset与rotate的调用先后顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .scale(scale)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .offset {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                IntOffset(offset.x.roundToInt(), offset.y.roundToInt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                detectTransformGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    panZoomLock = true, // 平移或放大时是否可以旋转</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onGesture = { centroid: Offset, pan: Offset, zoom: Float, rotation: Float -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        offset += pan</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        scale *= zoom</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ratationAngle += rotation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div align="center"><img src="/assets/images/transform-9b4172346bc8c9ecb20cb96966e06fc0.gif" width="50%" height="50%"></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="foreachgesture">forEachGesture<a class="hash-link" href="#foreachgesture" title="Direct link to heading">​</a></h3><p>前面提到 Compose 手势操作实际上是在协程中监听处理的，当协程处理完一轮手势交互后便会结束，当进行第二次手势交互时由于负责手势监听的协程已经结束，手势事件便会被丢弃掉。那我们该怎样才能让手势监听协程能够不断地处理每一轮的手势交互呢。我们很容易想到可以在外层嵌套一个 <code>while(true) </code>进行实现，然而这么做并不优雅，且也存在着一些问题。</p><p>当用户出现一连串手势操作时，很难保证各手势之间有清晰分界，即无法保证每一轮手势结束后，所有手指都是离开屏幕的。在传统 View 体系中，一次手指按下、移动到抬起过程中的所有手势事件可以看作是一个完整的手势交互序列。每当用户触摸屏幕交互时，我们可以根据这一次用户输入的手势交互序列中的手势信息进行相应的处理。</p><p>当第一轮手势处理结束或者被中断取消后，如果仍有手指留在屏幕。如果采用 <code>while(true)</code> 处理手势，则第二轮手势处理可能会使用第一轮手势交互序列中信息，导致出现不符预期的结果。</p><p>Compose 为我们提供了 <code>forEachGesture</code> 方法保证了每一轮手势处理逻辑的一致性。实际上前面我们所介绍的 GestureDetect 系列 API，其内部实现都使用了 <code>forEachGesture</code>。</p><p>通过 <code>forEachGesture</code> 的源码可知，每一轮手势处理结束后或本次手势处理被取消时，都会使用 <code>awaitAllPointersUp()</code> 保证所有手指均已抬起。并且同时也会与当前组件的生命周期对齐，当组件离开视图树时，手势监听也会随之结束。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun PointerInputScope.forEachGesture(block: suspend PointerInputScope.() -&gt; Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val currentContext = currentCoroutineContext()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (currentContext.isActive) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          block()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 挂起等待所有手指抬起</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          awaitAllPointersUp()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (e: CancellationException) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (currentContext.isActive) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 手势事件取消时，如果协程还存活则等待手指抬起再进行下一轮监听</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                awaitAllPointersUp()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw e</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="手势事件作用域-awaitpointereventscope">手势事件作用域 awaitPointerEventScope<a class="hash-link" href="#手势事件作用域-awaitpointereventscope" title="Direct link to heading">​</a></h2><p>我们前面介绍的 <code>GestureDetector</code> 系列 API 本质上仍然是一种封装，既然手势处理是在协程中完成的，所以<strong>手势监听必然是通过协程的挂起恢复实现的，以取代传统的回调监听方式</strong>。要想深入理解 Compose 手势处理，就需要学习更为底层的手势处理挂起方法。</p><p>在 <code>PointerInputScope</code> 中我们使用 <code>awaitPointerEventScope</code> 方法获得 <code>AwaitPointerEventScope</code> 作用域，在<code> AwaitPointerEventScope</code> 作用域中我们可以使用 Compose 中所有低级别的手势处理挂起方法。当 <code>awaitPointerEventScope</code> 内所有手势事件都处理完成后 <code>awaitPointerEventScop</code>e 便会恢复执行将 Lambda 中最后一行表达式的数值作为返回值返回。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun &lt;R&gt; awaitPointerEventScope(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block: suspend AwaitPointerEventScope.() -&gt; R</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): R</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们在 <code>AwaitPointerEventScope</code> 中发现了以下这些基础手势方法，可以发现这些 API 均是挂起函数，接下来我们会对每个 API 进行描述说明。</p><table><thead><tr><th>API名称</th><th>作用</th></tr></thead><tbody><tr><td>awaitPointerEvent</td><td>手势事件</td></tr><tr><td>awaitFirstDown</td><td>第一根手指的按下事件</td></tr><tr><td>drag</td><td>拖动事件</td></tr><tr><td>horizontalDrag</td><td>水平拖动事件</td></tr><tr><td>verticalDrag</td><td>垂直拖动事件</td></tr><tr><td>awaitDragOrCancellation</td><td>单次拖动事件</td></tr><tr><td>awaitHorizontalDragOrCancellation</td><td>单次水平拖动事件</td></tr><tr><td>awaitVerticalDragOrCancellation</td><td>单次垂直拖动事件</td></tr><tr><td>awaitTouchSlopOrCancellation</td><td>有效拖动事件</td></tr><tr><td>awaitHorizontalTouchSlopOrCancellation</td><td>有效水平拖动事件</td></tr><tr><td>awaitVerticalTouchSlopOrCancellation</td><td>有效垂直拖动事件</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_mojV" id="事件之源-awaitpointerevent">事件之源 awaitPointerEvent<a class="hash-link" href="#事件之源-awaitpointerevent" title="Direct link to heading">​</a></h3><p>之所以称这个 API 为事件之源，因为上层所有手势监听 API 都是基于这个 API 实现的，他的作用类似于传统 View 中的 <code>onTouchEvent() </code>。无论用户是按下、移动或抬起都将视作一次手势事件，当手势事件发生时 <code>awaitPointerEvent</code> 便会恢复返回监听到的屏幕上所有手指的交互信息。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">forEachGesture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        var event = awaitPointerEvent()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Log.d(TAG, &quot;x: ${event.changes[0].position.x}, y: ${event.changes[0].position.y}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="手势事件分发">手势事件分发<a class="hash-link" href="#手势事件分发" title="Direct link to heading">​</a></h4><p>实际上 <code>awaitPointerEvent</code> 存在着一个可选参数 <code>PointerEventPass</code>，这个参数实际上是用来定制手势事件分发顺序的。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun awaitPointerEvent(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pass: PointerEventPass = PointerEventPass.Main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): PointerEvent</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>通过 API 声明可以看到 <code>awaitPointerEvent</code> 有个可选参数 <code>PointerEventPass</code>，这个参数实际上是用来定制手势事件分发顺序的。</p><p>PointerEventPass 有 3 个枚举值可以让我们来决定手势的处理阶段。在 Compose 中，手势处理共有三个阶段：</p><ul><li>Initial：自上而下的分发手势事件</li><li>Main：自下而上的分发手势事件</li><li>Final：自上而下的分发手势事件</li></ul><p>在 Inital 阶段，手势事件会在所有使用 Inital 参数的组件间<strong>自上而下</strong>的完成首次分发。利用 Inital 可以使父组件能够预先劫持消费手势事件，这类似于传统 View 中 onInterceptTouchEvent 的作用。</p><p>在 Main 阶段，手势事件会在所有使用 Main 参数的组件间<strong>自下而上</strong>的完成第二次分发。利用 Main 可以使子组件能先于父组件完成手势事件的处理，这有些类似于传统 View 中 onTouchEvent 的作用。</p><p>在 Final 阶段，手势事件会在所有使用 Final 参数的组件间<strong>自上而下</strong>的完成最后一次分发。Final阶段一般用来让组件了解经历过前面几个阶段后的手势事件消费情况，从而确定自身行为。例如按钮组件可以不再手指从按钮上移动开的事件，因为这个事件可能已被父组件滚动器用于滚动消费了</p><p>接下来我们通过一个嵌套组件的手势监听来演示事件的分发过程。当所有组件的手势监听均默认使用 Main 时，事件分发顺序为：第三层 -&gt; 第二层 -&gt; 第一层</p><div align="center"><img src="/assets/images/boxnest-d760d722aea90333405ae8d41840d710.jpg" width="50%" height="50%"></div><p>而如果第一层组件使用 Inital，第二层组件使用 Final ，第三层组件使用 Main，事件分发顺序为：第一层 -&gt; 第三层 -&gt; 第二层</p><div align="center"><img src="/assets/images/boxnest2-f8106ce12d6f5ff640d4bcaa2cbd91a0.jpg" width="50%" height="50%"></div><p>接下来，我们换作四层嵌套来观察手势事件的分发，其中第一层与第三层使用 Initial，第二层使用 Final，第三层使用 Main，事件分发顺序为：第一层 -&gt; 第三层 -&gt; 第四层 -&gt; 第二层</p><div align="center"><img src="/assets/images/boxnest3-297e1ae52c391254602084323189b920.jpg" width="50%" height="50%"></div><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun NestedBoxDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(400.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(Color.Red)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    awaitPointerEvent(PointerEventPass.Initial)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Log.d(TAG, &quot;first layer&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .size(200.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .background(Color.Blue)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        awaitPointerEvent(PointerEventPass.Final)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Log.d(TAG, &quot;second layer&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .size(100.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            awaitPointerEvent(PointerEventPass.Initial)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            Log.d(TAG, &quot;third layer&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .size(50.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .background(Color.White)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                awaitPointerEvent(PointerEventPass.Main)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                Log.d(TAG, &quot;fourth layer&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="手势事件消费">手势事件消费<a class="hash-link" href="#手势事件消费" title="Direct link to heading">​</a></h4><p>在了解手势事件分发之后，我们接下来学习如何完成手势事件消费，我们看到 <code>awaitPointerEvent</code> 返回了一个 <code>PointerEvent</code> 实例。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">actual data class PointerEvent internal constructor(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    actual val changes: List&lt;PointerInputChange&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    internal val motionEvent: MotionEvent?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>从 PointerEvent 类的声明中可以看到包含了两个属性 changes 与 motionEvent。</p><ul><li><strong>motionEvent</strong>：实际上就是传统 View 系统中的 MotionEvent，由于被声明 internal ，说明官方并不希望我们直接拿来使用。</li><li><strong>changes</strong>：其中包含了一次手势交互中所有手指的交互信息。在多指操作时，利用 <code>changes</code> 可以轻松定制多指手势处理。</li></ul><p>可以看出<strong>单指交互的完整信息被封装在了一个 PointerInputChange 实例中</strong>，接下来我们看看 PointerInputChange 提供了哪些手势信息。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">class PointerInputChange(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val id: PointerId, // 手指Id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val uptimeMillis: Long, // 当前手势事件的时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val position: Offset, // 当前手势事件相对组件左上角的位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val pressed: Boolean, // 当前手势是否按下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val previousUptimeMillis: Long, // 上一次手势事件的时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val previousPosition: Offset, // 上一次手势事件相对组件左上角的位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val previousPressed: Boolean, // 上一次手势是否按下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val consumed: ConsumedData, // 当前手势是否已被消费</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val type: PointerType = PointerType.Touch // 手势类型(鼠标、手指、手写笔、橡皮) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>利用这些丰富的手势信息，我们可以在上层定制实现各类复杂的交互手势。</p><p>可以看到其中的 consumed 成员记录着该事件是否已被消费，我们可以使用 <code>PointerInputChange</code> 提供的 consume 系列 API 来修改这个手势事件的消费标记。</p><table><thead><tr><th>API名称</th><th>作用</th></tr></thead><tbody><tr><td>changedToDown</td><td>是否已经按下(按下手势已消费则返回false)</td></tr><tr><td>changedToDownIgnoreConsumed</td><td>是否已经按下(忽略按下手势已消费标记)</td></tr><tr><td>changedToUp</td><td>是否已经抬起(按下手势已消费则返回false)</td></tr><tr><td>changedToUpIgnoreConsumed</td><td>是否已经抬起(忽略按下手势已消费标记)</td></tr><tr><td>positionChanged</td><td>是否位置发生了改变(移动手势已消费则返回false)</td></tr><tr><td>positionChangedIgnoreConsumed</td><td>是否位置发生了改变(忽略已消费标记)</td></tr><tr><td>positionChange</td><td>位置改变量(移动手势已消费则返回Offset.Zero)</td></tr><tr><td>positionChangeIgnoreConsumed</td><td>位置改变量(忽略移动手势已消费标记)</td></tr><tr><td>positionChangeConsumed</td><td>当前移动手势是否已被消费</td></tr><tr><td>anyChangeConsumed</td><td>当前按下手势或移动手势是否有被消费</td></tr><tr><td>consumeDownChange</td><td>消费按下手势</td></tr><tr><td>consumePositionChange</td><td>消费移动手势</td></tr><tr><td>consumeAllChanges</td><td>消费按下与移动手势</td></tr><tr><td>isOutOfBounds</td><td>当前手势是否在固定范围内</td></tr></tbody></table><p>前面提到，我们可以通过设置 <code>PointerEventPass</code> 来定制嵌套组件间手势事件分发顺序。假设分发流程中组件 A 预先获取到了手势信息并进行消费，手势事件仍然会被之后的组件 B 获取得到。组件 B 在使用 <code>positionChange</code> 获取的偏移值时会返回 <code>Offset.ZERO</code>，这是因为此时该手势事件已被标记为已消费的状态。当然组件 B 也可以通过 IgnoreConsumed 系列 API 突破已消费标记的限制获取到手势信息。</p><p>我们仍然通过前面使用的嵌套组件示例子来看看手势事件的消费。我们的嵌套组件中第一层组件使用 Inital，第二层组件使用 Final ，第三层组件使用 Main。</p><div align="center"><img src="/assets/images/boxnest2-f8106ce12d6f5ff640d4bcaa2cbd91a0.jpg" width="50%" height="50%"></div><p>我们在第三层组件的手势事件监听中进行消费，因为我们知道手势事件会交由第一层, 再交由第三层，最后交由第二层。第三层组件处于本次手势分发流程的中间位置。</p><p>当我们在第三层组件消费了<code> ACTION_DOWN</code> 后，之后处理的第二层组件接收的手势事件仍是被标记为消费状态的。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun ConsumeDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .fillMaxSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    var event = awaitPointerEvent(PointerEventPass.Initial)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Log.d(TAG, &quot;first layer, downChange: ${event.changes[0].consumed.downChange}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .size(400.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .background(Color.Blue)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        var event = awaitPointerEvent(PointerEventPass.Final)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Log.d(TAG, &quot;second layer, downChange: ${event.changes[0].consumed.downChange}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .size(200.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            var event = awaitPointerEvent()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            event.changes[0].consumeDownChange() // 消费手势事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            Log.d(TAG, &quot;third layer, downChange: ${event.changes[0].consumed.downChange}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>介绍完 Compose 的手势事件分发与消费，想必大家已经对 <code>awaitPointerEvent</code> 这个低级别基础手势监听 API 已经有了足够的了解。然而在实际场景中我们还是应该更多的依赖上层封装完善的 API，因为当手势逻辑变得越来越复杂时，维护手势交互处理逻辑的难度也会越来越大。接下来我们来介绍 <code>AwaitPointerEventScope</code> 中基于 <code>awaitPointerEvent</code> 实现的几个常用手势监听挂起方法。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="awaitfirstdown">awaitFirstDown<a class="hash-link" href="#awaitfirstdown" title="Direct link to heading">​</a></h3><p><code>awaitFirstDown</code> 将等待第一根手指 <code>ACTION_DOWN</code> 事件时恢复执行，并将手指按下事件返回。翻阅源码可以看出其内部实现原理并不复杂。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun AwaitPointerEventScope.awaitFirstDown(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requireUnconsumed: Boolean = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): PointerInputChange {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var event: PointerEvent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 监听手势事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        event = awaitPointerEvent()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 遍历每一根手指的事件信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        !event.changes.fastAll {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 需要没有被消费过的手势事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (requireUnconsumed) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 返回该事件是否是一个还没有被消费的DOWN事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 当返回 false 时说明是不是DOWN事件或已被消费的DOWN事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                it.changedToDown()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 返回该事件是否是一个DOWN事件，忽略是否已被消费</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 当返回 false 时说明是不是DOWN事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                it.changedToDownIgnoreConsumed()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 返回第一根手指的事件信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return event.changes[0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="drag">drag<a class="hash-link" href="#drag" title="Direct link to heading">​</a></h3><p>我们前面提到的 <code>detectDragGestures</code>，以及更为上层的 <code>Draggable</code> 修饰符内部都是使用 <code>drag</code> 挂起方法来实现拖动监听的。通过函数签名可以看到我们不仅需要手指拖动的监听回调，还需传入手指的标识信息，表示监听具体哪根手指的拖动手势。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun AwaitPointerEventScope.drag(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pointerId: PointerId,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDrag: (PointerInputChange) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们可以先利用 <code> awaitFirstDown</code> 获取到记录着交互信息的 <code>PointerInputChange</code> 实例，其中 <code>id</code> 字段记录着发生 <code> ACTION_DOWN</code> 事件的手指标识信息。通过结合 <code>forEachGesture</code>、<code>awaitFirstDown</code> 与 <code>drag</code>，我们便可以实现一个简单的拖动手势监听了。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun BaseDragGestureDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var boxSize = 100.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var offset by remember { mutableStateOf(Offset.Zero) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier.fillMaxSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(boxSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .offset {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                IntOffset(offset.x.roundToInt(), offset.y.roundToInt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                forEachGesture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 获取第一根手指的DOWN事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        var downEvent = awaitFirstDown()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 根据手指标识符跟踪多痛手势</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        drag(downEvent.id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 根据手势位置改变量更新偏移量状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            offset += it.positionChange()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="awaitdragorcancellation">awaitDragOrCancellation<a class="hash-link" href="#awaitdragorcancellation" title="Direct link to heading">​</a></h3><p>与 <code>drag</code> 不同的是，<code>awaitDragOrCancellation</code> 负责监听单次拖动事件。当手指已经抬起或拖动事件已经被消费时会返回 null。当然我们也可以使用 <code>awaitDragOrCancellation</code> 来完成 UI 拖动手势处理流程。通过翻阅源码可以发现 <code>drag</code> 其实内部也是使用 <code>awaitDragOrCancellation</code> 进行实现的。而 <code>awaitDragOrCancellation</code> 内部仍然是事件之源 <code>awaitPointerEvent</code>。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Box(Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .size(boxSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .offset {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IntOffset(offset.x.roundToInt(), offset.y.roundToInt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        forEachGesture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 获取第一根手指的DOWN事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                var downPointer = awaitFirstDown()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 根据手指标识符跟踪拖动手势，手指抬起货拖动事件被消费时返回null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    var event = awaitDragOrCancellation(downPointer.id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (event == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 根据手势位置改变量更新偏移量状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    offset += event.positionChange()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="awaittouchsloporcancellation">awaitTouchSlopOrCancellation<a class="hash-link" href="#awaittouchsloporcancellation" title="Direct link to heading">​</a></h3><p><code>awaitTouchSlopOrCancellation</code> 用于监测当前拖动手势是否是一次有效的拖动。有效指的是当前手势滑动的欧式距离(位移)是否超过设定的阈值。若拖动手势还没有达到阈值便抬起或拖动手势事件已经被消费时将返回null，翻阅源码我们也可以发现最终仍然使用 <code>awaitPointerEvent</code> 来完成手势监听的。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun AwaitPointerEventScope.awaitTouchSlopOrCancellation(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pointerId: PointerId,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onTouchSlopReached: (change: PointerInputChange, overSlop: Offset) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): PointerInputChange? {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val touchSlop = viewConfiguration.touchSlop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var pointer = pointerId</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val event = awaitPointerEvent()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (dragEvent.positionChangeConsumed()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (dragEvent.changedToUpIgnoreConsumed()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (distance &gt;= touchSlop) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们前面所提到的 <code>detectDragGestures</code> 其内部不仅使用了 <code>drag</code> 还使用了 <code>awaitTouchSlopOrCancellation</code> 来判断手势拖动操作。仅当监测为一次有效的拖动时，才会执行<code> onDragStart</code> 回调。接下来就是使用 <code>drag</code> 来监听拖动手势，仅当 <code>drag</code> 返回 false (即在拖动过程中事件分发流程前面的组件达成定制条件消费了这次的拖动手势事件) 会执行 onDragCancel 回调，否则如果所有手指抬起正常结束则会执行 <code>onDragEnd</code> 回调。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun PointerInputScope.detectDragGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragStart: (Offset) -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragEnd: () -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragCancel: () -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDrag: (change: PointerInputChange, dragAmount: Offset) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    forEachGesture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                drag = awaitTouchSlopOrCancellation(down.id) { change, over -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    change.consumePositionChange()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    overSlop = over</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } while (drag != null &amp;&amp; !drag.positionChangeConsumed())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (drag != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                onDragStart.invoke(drag.position) // 拖动开始</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                onDrag(drag, overSlop)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    !drag(drag.id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        onDrag(it, it.positionChange())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        it.consumePositionChange()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onDragCancel() // 拖动取消</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onDragEnd()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/milklabdev/jetpack-compose-book/tree/master/docs/design/gesture/customGesture.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/design/gesture/nestedScroll"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">嵌套滑动（nestedScroll）</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/category/列表lists"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">列表（Lists）</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#使用-pointerinput-modifier" class="table-of-contents__link toc-highlight">使用 PointerInput Modifier</a><ul><li><a href="#拖动类型基础-api" class="table-of-contents__link toc-highlight">拖动类型基础 API</a></li><li><a href="#点击类型基础-api" class="table-of-contents__link toc-highlight">点击类型基础 API</a></li><li><a href="#变换类型基础-api" class="table-of-contents__link toc-highlight">变换类型基础 API</a></li><li><a href="#foreachgesture" class="table-of-contents__link toc-highlight">forEachGesture</a></li></ul></li><li><a href="#手势事件作用域-awaitpointereventscope" class="table-of-contents__link toc-highlight">手势事件作用域 awaitPointerEventScope</a><ul><li><a href="#事件之源-awaitpointerevent" class="table-of-contents__link toc-highlight">事件之源 awaitPointerEvent</a></li><li><a href="#awaitfirstdown" class="table-of-contents__link toc-highlight">awaitFirstDown</a></li><li><a href="#drag" class="table-of-contents__link toc-highlight">drag</a></li><li><a href="#awaitdragorcancellation" class="table-of-contents__link toc-highlight">awaitDragOrCancellation</a></li><li><a href="#awaittouchsloporcancellation" class="table-of-contents__link toc-highlight">awaitTouchSlopOrCancellation</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/milklabdev" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Milk Lab, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.be34a282.js"></script>
<script src="/assets/js/main.01e4ab04.js"></script>
</body>
</html>