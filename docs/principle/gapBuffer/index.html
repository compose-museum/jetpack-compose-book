<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">Compose 运行原理与 GapBuffer | 你好 Compose</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://docs.compose.net.cn/docs/principle/gapBuffer"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Compose 运行原理与 GapBuffer | 你好 Compose"><meta data-react-helmet="true" name="description" content="揭秘 @Composable"><meta data-react-helmet="true" property="og:description" content="揭秘 @Composable"><link data-react-helmet="true" rel="icon" href="/img/logo.svg"><link data-react-helmet="true" rel="canonical" href="https://docs.compose.net.cn/docs/principle/gapBuffer"><link data-react-helmet="true" rel="alternate" href="https://docs.compose.net.cn/docs/principle/gapBuffer" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://docs.compose.net.cn/docs/principle/gapBuffer" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.8bcaa596.css">
<link rel="preload" href="/assets/js/runtime~main.8f97f74f.js" as="script">
<link rel="preload" href="/assets/js/main.4bfc8ca0.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Jetpack Compose 博物馆</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/">文档</a><a class="navbar__item navbar__link" href="/docs/open-source-project/compose-douban">开源项目</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/compose-museum/hello-compose" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">写在开头</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/入门">入门</a><button aria-label="Toggle the collapsible sidebar category &#x27;入门&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/installation">安装或更新 Android Studio</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorial">初识 Jetpack Compose</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/elements/alertdialog">基础组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/layout/bottomnavigation">布局组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/设计">设计</a><button aria-label="Toggle the collapsible sidebar category &#x27;设计&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/动画animation">动画（Animation）</a><button aria-label="Toggle the collapsible sidebar category &#x27;动画（Animation）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/主题theming">主题（Theming）</a><button aria-label="Toggle the collapsible sidebar category &#x27;主题（Theming）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/手势gesture">手势（Gesture）</a><button aria-label="Toggle the collapsible sidebar category &#x27;手势（Gesture）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/列表lists">列表（Lists）</a><button aria-label="Toggle the collapsible sidebar category &#x27;列表（Lists）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/resources">资源</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" href="/docs/category/技术原理">技术原理</a><button aria-label="Toggle the collapsible sidebar category &#x27;技术原理&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/recompositionScope">了解 Compose 的重组作用域</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/snapshot">透过 Snapshot 看重组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/recomposeWorkingPrinciple">重组的工作流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/principle/gapBuffer">Compose 运行原理与 GapBuffer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/modifierStructure">图解 Modifier</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Compose 运行原理与 GapBuffer</h1></header><h2 class="anchor anchorWithStickyNavbar_mojV" id="揭秘-composable">揭秘 @Composable<a class="hash-link" href="#揭秘-composable" title="Direct link to heading">​</a></h2><p>如果你已经看过 <code>Compose</code>，你可能在很多的示例代码中看到过 <code>@Composable</code> 注解。有一件很重要的事必须说明，<code>Compose</code> 没有使用注解处理器。<code>Compose</code> 在 <code>Kotlin</code> 编译插件在类型检查和代码生成阶段工作，因此不需要使用注解处理器。</p><p>这个注解更像是一个关键字。就像 <code>Kotlin</code> 里面的 <code>suspend</code> 关键字一样。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// function declaration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun MyFun() { … }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// lambda declaration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val myLambda = suspend { … }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// function type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun MyFun(myParam: suspend () -&gt; Unit) { … }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Kotlin 的 <code>suspend</code> 关键字会用在函数类型，你可以定义一个函数、<code>lambda</code> 或者是类型是 <code>suspend</code> 的。<code>Compose</code> 也一样，它可以改变函数的类型。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// function declaration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable fun MyFun() { … }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// lambda declaration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val myLambda = @Composable { … }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// function type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun MyFun(myParam: @Composable () -&gt; Unit) { … }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>有一点很重要这里必须要说明，当你为一个函数添加了 <code>@Composable</code> 注解时，你就改变了这个函数类型。也就是说，相同函数类型没有注解和有注解是不兼容的。同样的，<code>suspend</code> 函数也需要一个调用的上下文，意思就是只能在只能在另一个 <code>suspend</code> 函数里面调用 <code>suspend</code> 函数。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Example(a: () -&gt; Unit, b: suspend () -&gt; Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   a() // allowed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   b() // NOT allowed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun Example(a: () -&gt; Unit, b: suspend () -&gt; Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   a() // allowed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   b() // allowed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>Composable</code> 工作方式也是一样的。因为有一个调用上下文的对象贯穿这整个调用。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Example(a: () -&gt; Unit, b: @Composable () -&gt; Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   a() // allowed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   b() // NOT allowed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Example(a: () -&gt; Unit, b: @Composable () -&gt; Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   a() // allowed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   b() // allowed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="基于-gapbuffer-的运行过程">基于 GapBuffer 的运行过程<a class="hash-link" href="#基于-gapbuffer-的运行过程" title="Direct link to heading">​</a></h2><p>那么，这个我们传递的上下文是什么呢？还有为什么我们需要这么做？</p><p>我们把这个对象叫 “Composer”。<code>Composer</code> 的实现包含了一个跟 <a href="https://en.wikipedia.org/wiki/Gap_buffer" target="_blank" rel="noopener noreferrer">Gap Buffer</a> 很类似的数据结构。这个数据结构经常用在文本编辑器里面。</p><p><code>Gap Buffer</code> 表示的是一个包含了 <code>index</code> 和 <code>cursor</code> 的集合。在内存里面它就是一个扁平的数组。这个扁平的数组会比实际表示的数据要大一些，其中没有使用的空间就是 <code>gap</code>。</p><img src="/assets/images/demo1-d48fa39856ad2085eb363ba9838e2fce.png" height="400" width="400"><p>现在，一个正在执行的 <code>Composable</code> 层级会用这个数据结构插入数据。</p><img src="/assets/images/demo2-7b82c2ff4d462647e5087be9700417a3.png" height="400" width="400"><p>假设我们已经完成了这个层级结构的数据插入。有时候，我们需要 <code>rcompose</code>，因此我们需要重置 <code>cursor</code> 到数组的顶部并重新再次遍历整个数组。当我们在执行的时候我们可以根据数据看是否需要更新值。</p><img src="/assets/images/demo3-904dff2c946260519f5dd41049ad054d.png" height="400" width="400"><p>可能因为UI结构的改变我们想要插入数据，这个时候我们就把 <code>gap</code> 移动到了当前的位置。</p><img src="/assets/images/demo4-a6b8726dad3a5f25c073de951f39c67b.png" height="400" width="400"><p>现在我们可以插入数据了。</p><img src="/assets/images/demo5-cfa1c528749c650f818cf8ec7cbdd1b3.png" height="400" width="400"><p>很重要的一点是我们需要理解这个数据结构的所有的操作—— <code>get</code>, <code>move</code>, <code>insert</code>, <code>delete</code> ——都是常量阶时间复杂度的操作，除了移动gap时间复杂度是 O(n)。我们选择这个数据结构的原因是因为我们认为，平均来说，<code>UI</code> 结构的变化不会太多。动态的UI通常是根据数据值的变化，而结构的变化不会经常发生。如果确实发生了结构行的变化，通常是一大块的变化，因此执行 O(n) 复杂度的 <code>gap</code> 移动也是合理的权衡。</p><p>让我们看一个 <code>counter</code> 的示例：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Counter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> var count by remember { mutableStateOf(0) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Button(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   text = &quot;Count: $count&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   onClick = { count += 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们写代码会这么写，编译器会为我们做什么呢？</p><p>当编译器看到 <code>Composable</code> 注解时便会插入额外的参数并在函数体内调用。</p><p>首先，编译器添加了一个 <code>Composer.start</code> 的调用并传入一个在编译期生成的整型关键字。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Counter($composer: Composer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> $composer.start(123)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> var count by remember { mutableStateOf(0) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Button(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   text = &quot;Count: $count&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   onClick = { count += 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> $composer.end()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>编译器还把 <code>Composer</code> 的对象传递到了所有的函数体内部有 <code>Composable</code> 的地方。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Counter($composer: Composer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> $composer.start(123)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> var count by remember($composer) { mutableStateOf(0) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Button(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   $composer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   text = &quot;Count: $count&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   onClick = { count += 1 },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> $composer.end()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>当一个 <code>Composer</code> 执行，它做了下面这些事情：</p><ul><li><code>Composer.start</code> 被执行了，并且保存了一个组对象</li><li><code>remember</code> 插入的组对象</li><li>状态实例 <code>mutableStateOf</code> 返回的值被存储了下来</li><li><code>Button</code> 每个参数后面也持有了一个组对象</li></ul><p>最后我们走到了 <code>Composer.end</code>。</p><img src="/assets/images/demo6-52acafc1ba21cfeb7c463366211b3d9f.png" height="400" width="400"><p>现在这个数据结构持有了这个 <code>composition</code> 的所有对象，按照整个树的执行顺序排序，实际上是整个树的深度优先遍历。</p><p>现在所有这些组对象占用了很多的空间，那这到底是为了什么呢？这些组对象存在的目的是为了管理 <code>move</code> 和 <code>insert</code> 这些可能发生在动态UI的操作。编译器知道会改变 <code>UI</code> 结构代码是什么样子，因此它可以根据条件来插入这些组。大部分情况下，编译器不需要这些组，因此它不会插入那么多的组到 <code>slot table</code> 里面。为了演示具体情况我们看下面这个条件逻辑。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun App() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> val result = getData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> if (result == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Loading(...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Header(result)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Body(result)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>在这个 <code>Composable</code> 里面，<code>getData</code> 函数会返回一些结果，当 <code>result == null</code> 时会渲染 <code>Loading</code>  ，在另一个场景下会渲染 <code>Header</code> 和 <code>Body</code> 。编译器会分别插入两个不同的整形关键字给 <code>if</code> 语句的条件分支。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun App($composer: Composer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> val result = getData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> if (result == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   $composer.start(123)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Loading(...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   $composer.end()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   $composer.start(456)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Header(result)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Body(result)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   $composer.end()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>让我们假设一开始这个代码执行结果返回的是 null。那么就是插入一个组到 <code>gap</code> 数组里面，然后屏幕开始 <code>loading</code>。</p><img src="/assets/images/demo7-49ea292386ec5eef43e46a9b7dd24b88.png" height="400" width="400">&gt;<p>接着我们假设返回的结果不再是 null，因此 <code>if</code> 语句的第二个分支被执行了。这也是它有意思的地方。</p><p><code>Composer.start</code> 执行入了一个整形关键字为 456 的组。编译器发现这个组跟表里面的 123 不匹配，因此它知道 <code>UI</code> 的结构发生了变化。</p><p>然后编译器就把 <code>gap</code> 移动到当前的位置并扩大，实际上舍弃了旧的 <code>UI</code>。</p><p>这个时候，代码正常执行，还有新的 <code>Header</code> 和 <code>Body</code> 都被插入进来。</p><img src="/assets/images/demo8-0ad3a8eebe87fa6ddfadb6d49e89b3a2.png" height="400" width="400"><p>在这个例子里面，if 语句只是 <code>slot table</code> 里一个 <code>slot entry</code>。通过插入一个组让我们能够操控 <code>UI</code> 的控制流，让编译器能够去管理，当在执行 <code>UI</code> 的时候可以用这些类似缓存的数据结构。</p><p>这个概念我们称其为“基于位置的 memoization ”，这也是 <code>Compose</code> 始终在使用的概念。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="基于位置的-memoization">基于位置的 memoization<a class="hash-link" href="#基于位置的-memoization" title="Direct link to heading">​</a></h2><p>通常，我们有一个通用的 <code>memoization</code> ，其含义是编译器会根据函数输入的参数缓存函数的结果。为了说明基于位置的 <code>memoization</code>，我们创建了一个 <code>Composable</code> 来执行一些计算。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun App(items: List&lt;String&gt;, query: String) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> val results = items.filter { it.matches(query) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这个函数传入一个 <code>items</code> 列表和一个 <code>query</code> 字符串，然后执行了针对传入的 <code>items</code> 做了一个 <code>filter</code> 过滤计算。我们可以把这个计算包装到一个记录的调用里面（记录指的是知道怎么像表发起请求）。在返回之前，这个过滤器计算完并且把结果记录下来。</p><p>当这个函数再次被执行的时候，拿新传递进来的值同历史记录做对比，如果没变化，过滤操作会被跳过，之前的结果直接返回。这就是 <code>memoization</code>。</p><p>有趣的是，这个操作开销很小，编译器只需要存储之前的调用。这个计算可能会发生在整个 <code>UI</code> 的过程中，因为你是根据位置存储的，只有在那个位置才会存储。</p><p>下面是 <code>remember</code> 函数的签名，它是一个可变参数和计算函数的作为参数的函数。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun &lt;T&gt; remember(vararg inputs: Any?, calculation: () -&gt; T): T</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这里有一个比较有意思的退化场景，在没有参数的时候，我们能做的一件事就是故意错误使用这个 <code>API</code>。我们可以故意传一个脏数据进行计算，比如 <code>Math.random()</code>。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable fun App() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> val x = remember { Math.random() }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>如果你正在做的是一个全局的 <code>memoization</code> 的话那就没有意义。但是基于位置的 <code>memoization</code>，它将会是一个新的语义。每次我们用 <code>Composable</code> 的层级，<code>Math.random</code> 都会返回新值。但是，每次 <code>Composable</code> 被重新组合的时候，<code>Math.random</code> 都会返回相同的值。这样就可以持久化，持久化就可以进行状态管理了。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="存储参数">存储参数<a class="hash-link" href="#存储参数" title="Direct link to heading">​</a></h2><p>为了演示 <code>Composable</code> 函数的参数是怎么被保存的，我们用 Google 这个 <code>Composable</code>函数，它有一个 <code>Int</code> 类型的 <code>number</code> 入参，里面调用了一个叫 <code>Address</code> 的 <code>Composable</code>，然后渲染<code>Address</code>。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Google(number: Int) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Address(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   number=number,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   street=&quot;Amphitheatre Pkwy&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   city=&quot;Mountain View&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   state=&quot;CA&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   zip=&quot;94043&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Address(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> number: Int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> street: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> city: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> state: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> zip: String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Text(&quot;$number $street&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Text(city)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Text(&quot;, &quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Text(state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Text(&quot; &quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Text(zip)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>compose</code> 将 <code>Composable</code> 函数的参数保存在表里面。如果是这样的话，我们看下上面的例子会有一些冗余，“Mountain View” 和 “CA”，这两个添加到地址里面会随着文本的调用再次存储，因此这些字符串会被存储两次。</p><p>我们可以在编译阶段通过添加 <code>static</code> 的参数来避免这种冗余。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Google(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> $composer: Composer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> $static: Int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> number: Int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Address(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   $composer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   0b11110 or ($static and 0b1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   number=number,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   street=&quot;Amphitheatre Pkwy&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   city=&quot;Mountain View&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   state=&quot;CA&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   zip=&quot;94043&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这个例子中 <code>static</code> 是一个整数字段表示运行时是否知道参数有没有发生改变。如果参数没变，那么就没必要去存数据。因此在这个 <code>Google</code> 的例子里面，编译器传入了一个参数用以表示是否会发生改变。</p><p>那么在 <code>Address</code> 里，编译器同样可以这么做，把它传给字符串。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Address(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  $composer: Composer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  $static: Int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  number: Int, street: String, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  city: String, state: String, zip: String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Text($composer, ($static and 0b11) and (($static and 0b10) shr 1), &quot;$number $street&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Text($composer, ($static and 0b100) shr 2, city)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Text($composer, 0b1, &quot;, &quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Text($composer, ($static and 0b1000) shr 3, state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Text($composer, 0b1, &quot; &quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Text($composer, ($static and 0b10000) shr 4, zip)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这里的逻辑运算看起来比较晦涩也让人看起来比较困惑，但是我们没必要去理解它，这是编译器擅长的事情，我们不擅长处理。</p><p>在 <code>Google</code> 的示例里面，我们看到了冗余的信息，但也有一些常量。其实我们也没必要去存储它们。因此整个层级结构是由参数的数量决定的并且这也是唯一需要编译器去存储的。</p><p>正因如此，我们再进一步，生成了代码才理解那个数字是唯一会改变的东西。这段代码将会这样运行，如果这个数字没变的话，整个函数都会被跳过，然后我们可以引导 <code>Composer</code> 当前的 <code>index</code> 到下一个位置，就好像函数已经被执行了一样。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Google(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> $composer: Composer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> number: Int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> if (number == $composer.next()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Address(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     $composer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     number=number,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     street=&quot;Amphitheatre Pkwy&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     city=&quot;Mountain View&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     state=&quot;CA&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     zip=&quot;94043&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   $composer.skip()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>Composer</code> 知道需要快进到哪一步去恢复执行。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="重组">重组<a class="hash-link" href="#重组" title="Direct link to heading">​</a></h2><p>为了理解重组是怎么工作的，让我们再回头看下 <code>counter</code> 的例子。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Counter($composer: Composer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> $composer.start(123)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> var count = remember($composer) { mutableStateOf(0) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Button(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   $composer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   text=&quot;Count: ${count.value}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   onPress={ count.value += 1 },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> $composer.end()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>编译器给这个 <code>counter</code> 例子自动生成的代码有 <code>composer.start</code> 和 <code>composer.end</code>。不管 <code>counter</code> 什么时候执行，它通过读取 <code>APP</code> 模型实例的属性都能知道 <code>count</code> 的值。在运行时，不管什么时候调用 <code>composer.end</code>，我们都能选择是否返回值。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">$composer.end()?.updateScope { nextComposer -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Counter(nextComposer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>然后我们可以用该值调用 <code>updateScope</code> 方法，方法传一个 <code>lambda</code> 来告诉运行时在必要时怎么去重启这个 <code>Composable</code>。这个和 <code>LiveData</code> 接收一个 <code>lambda</code> 是一样。这里我们用可空（？）的原因是，返回值是可空的，为什么是可空的呢？因为如果我们在 <code>Counter</code> 运行的时候不读取任何模型对象，我们就没法告诉运行时怎么去更新，因为它永远不会更新。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="结语">结语<a class="hash-link" href="#结语" title="Direct link to heading">​</a></h2><p>你需要知道的是大部分这些细节只是实现细节。标准 <code>Kotlin</code> 函数库里面 <code>Composable</code> 函数会有不同的行为和能力，有时候理解它们怎么实现会对我们有所帮助，但是行为和能力不会变，实现是有可能变的。</p><p>同样的，<code>Compose</code> 的编译器在特定情形下可以生成更高效的代码。后续，我们也希望能进一步优化。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/compose-museum/hello-compose/tree/master/docs/principle/gapBuffer.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/principle/recomposeWorkingPrinciple"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">重组的工作流程</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/principle/modifierStructure"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">图解 Modifier</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#揭秘-composable" class="table-of-contents__link toc-highlight">揭秘 @Composable</a></li><li><a href="#基于-gapbuffer-的运行过程" class="table-of-contents__link toc-highlight">基于 GapBuffer 的运行过程</a></li><li><a href="#基于位置的-memoization" class="table-of-contents__link toc-highlight">基于位置的 memoization</a></li><li><a href="#存储参数" class="table-of-contents__link toc-highlight">存储参数</a></li><li><a href="#重组" class="table-of-contents__link toc-highlight">重组</a></li><li><a href="#结语" class="table-of-contents__link toc-highlight">结语</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/compose-museum" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Jetpack Compose 博物馆, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.8f97f74f.js"></script>
<script src="/assets/js/main.4bfc8ca0.js"></script>
</body>
</html>